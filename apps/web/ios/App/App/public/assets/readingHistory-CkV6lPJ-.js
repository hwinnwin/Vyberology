import{a as c}from"./index-BU0JQuHZ.js";const a="vyberology_reading_history",i=100,l=()=>typeof crypto<"u"&&crypto.randomUUID?crypto.randomUUID():`${Date.now()}-${Math.random().toString(36).substring(2,11)}`,y=t=>{try{if(console.log("[ReadingHistory] Attempting to save reading:",t.inputType,t.inputValue),typeof localStorage>"u"){console.error("[ReadingHistory] localStorage is not available");return}const e=s(),r={...t,id:l(),timestamp:new Date().toISOString()};console.log("[ReadingHistory] Created new reading with ID:",r.id),e.unshift(r),e.length>i&&e.splice(i),localStorage.setItem(a,JSON.stringify(e)),console.log("[ReadingHistory] Successfully saved. Total readings:",e.length)}catch(e){console.error("[ReadingHistory] Failed to save reading to history:",e),e instanceof Error&&(console.error("[ReadingHistory] Error details:",e.message,e.stack),c(e,{context:"Reading History - Save Failed",level:"error",tags:{feature:"reading-history",operation:"save"},extra:{inputType:t.inputType,inputValue:t.inputValue,historyLength:history.length}}))}},s=()=>{try{if(typeof localStorage>"u")return console.error("[ReadingHistory] localStorage is not available for reading"),[];const t=localStorage.getItem(a);if(console.log("[ReadingHistory] Retrieved history, found:",t?"data exists":"no data"),!t)return[];const e=JSON.parse(t);return console.log("[ReadingHistory] Parsed history, count:",e.length),e}catch(t){return console.error("[ReadingHistory] Failed to load reading history:",t),t instanceof Error&&(console.error("[ReadingHistory] Error details:",t.message),c(t,{context:"Reading History - Load Failed",level:"warning",tags:{feature:"reading-history",operation:"load"}})),[]}},u=t=>{try{const r=s().filter(o=>o.id!==t);localStorage.setItem(a,JSON.stringify(r))}catch(e){console.error("Failed to delete reading:",e)}},h=()=>{try{localStorage.removeItem(a)}catch(t){console.error("Failed to clear history:",t)}},f=()=>{const t=s(),e={};return t.forEach(r=>{d(r.inputValue).forEach(n=>{e[n]=(e[n]||0)+1}),r.numbers&&r.numbers.forEach(n=>{e[n]=(e[n]||0)+1})}),Object.entries(e).map(([r,o])=>({pattern:r,count:o})).sort((r,o)=>o.count-r.count)},d=t=>{const e=[],r=t.match(/\d+/g);return r&&e.push(...r),e};export{f as a,h as c,u as d,s as g,y as s};
